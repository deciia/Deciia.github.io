{"title":"GLSL学习笔记1","slug":"course/GLSLlearning1","date":"2014-12-06T15:40:23.000Z","updated":"2017-05-12T02:15:21.953Z","comments":true,"path":"api/articles/course/GLSLlearning1.json","photos":[],"link":"","excerpt":"##关于矢量<br>vec2,vec3,vec4<br>ivec2…    x、y、z、w 将矢量看一个位置或方向<br>r、g、b、a 将矢量看作一种颜色<br>s、t、p、q 将矢量看一个纹理坐标选择矢量的分量 position.x  或者 position.xy 或者 position.xyzw都可以。<br>可以用数组的方式获得矢量的一个分量，如position[0] 等价于 position.x 。","covers":null,"content":"<p>##关于矢量<br>vec2,vec3,vec4<br>ivec2…    </p>\n<p>x、y、z、w 将矢量看一个位置或方向<br>r、g、b、a 将矢量看作一种颜色<br>s、t、p、q 将矢量看一个纹理坐标</p>\n<p>选择矢量的分量 position.x  或者 position.xy 或者 position.xyzw都可以。<br>可以用数组的方式获得矢量的一个分量，如position[0] 等价于 position.x 。</p>\n<a id=\"more\"></a>\n<p>##关于矩阵</p>\n<p>mat2,mat3,mat4,其中mat2在GMS的shader中没有定义。<br>如果transform是一个mat4，那么transform[2]就是transform的第三列，最终类型是一个vec4。<br><code>transform[2][1]</code>是指三列第二行。</p>\n<p>##取样器</p>\n<p>sampler1D,sampler2D,samplerCube,sampler1DShadow，sampler2DShadow</p>\n<pre><code>uniform sampler2D tex1;\n</code></pre><p>然后将变量传递到对应的纹理查找函数，以便访问一个纹理</p>\n<pre><code>vec3 col = texture2D(tex0,uv+textureOffset).xyz;\n</code></pre><p>着色器可能不会处理取样器值，例如<code>tex1+1</code>是不被允许的，如果一个着色器需要在程序里结合多个纹理，可以这样使有：</p>\n<pre><code>const int NumTextures=4;\nuniform sample2D textures[NumTextures];\n</code></pre><p>然后在循环中使用：</p>\n<pre><code>for (int i=0;i&lt;NumTextures;++i)\n    ...=texture2D(textures[i],...);\n</code></pre><p>然后 tex1+1就相当于纹理<code>[tex1Index+1],</code>这是指定取样器使用哪一种纹理的有效方式。</p>\n<p>##结构函数</p>\n<pre><code>struct light\n{\n    vec3 position;\n    vec3 color;\n}\n</code></pre><p>可以如下的方式声明light的变量</p>\n<pre><code>light ceilinglight;\n</code></pre><p>##数组</p>\n<p>可以创建任何类型的数组。如：<code>vec4 points[10];</code>，创建的是一个包含10个vec4的数组，索引从0开始，此处不存在指针，声明使用唯一方式是使用中括号。声明数组不必指定大小，如<code>vec4 points[0]</code>，只要使用的时候再次声明就可以了。另外静态使用的数组所有的索引都是编译的常量也可以这样使用。比如：<br>    vec4 points[]; //points是未知大小的数组<br>    points[2]=vec4(1.0);//现在是大小为3的数组<br>    points[7]=vec4(2.0);//现在是大小为8的数组</p>\n<h2 id=\"Void\"><a href=\"#Void\" class=\"headerlink\" title=\"Void\"></a>Void</h2><p>类型用来声明一个不返回任何值的函数，除此以外没有其它用途，如函数main就不会返回任何值，它必须声明为void类型。</p>\n<pre><code>void main()\n{\n   ...\n}\n</code></pre><h2 id=\"声明与作用域\"><a href=\"#声明与作用域\" class=\"headerlink\" title=\"声明与作用域\"></a>声明与作用域</h2><p> 可以在有需要的位置声明它们，作用域与C++一样。变量区分大小写，必须以一个字母或下划线开始，其只包含字母、下划线与数字，用户定义的变量不能以gl_开始，连续下划线“__”也被保留，使用时会跳出错误，可能会在将来使用而不能作为变量。</p>\n<p>初始化器与构造函数初始化（略）<br>类型转换（略）</p>\n<p>##限制符与着色器接口</p>\n<p>attribute 从应用程序直接传入到顶点着色器内置属性(gl_Vertex,gl_Normal)的信息<br>uniform 从应用程序传递句柄api，由应用程序传入变化的数值，两边都声明的同一个变量名是同一个变量<br>varying 顶点向片元着色器传递的信息，两边都要声明<br>const 只读常量，需要提前初始化</p>\n<p>限定的变量必须合局范围内声明。</p>\n<p>流控制没有switch关键字进行切换。<br>函数不能被递归使用。</p>\n<p>按值调用：限定为输入参数的参数将复制到函数中，并且不会作为引用传递。<br>按值返回调用：按返回调用意味着限定为输出参数的参数将返回到调用程序，这是通过在函数返回时将其从被调用函数复制到调用程序来实现的。</p>\n<p>要想指定复制哪些参数，可以在前前面使用限定符关键词in、out、inout<br>in 复进函数但不在返回时复制，在函数内部仍然可写，默认是这种类型<br>out 只在返回时复制，是可读的，但是进入函数时是未定义的<br>inout 复制进函数并在返回时复制 </p>\n<p>还可以对函数参数应用const限定符，不是作为一个编译时的常量，而是不允许函数写入变量。注意，可以写入一个普通的没有使用限定符的只输入参数，只是不能将它复制回调用程序。因此，限定为const in的参数与仅仅限定为in(或者没有限定符)的参数之间是存在差别的。当然out和inout参数不能被声明为const。</p>\n<p>下面是一个例子：</p>\n<pre><code>void ComputeCoord(in vec3 normal,  //将参数&quot;normal&quot;复制进函数，可以写入它，但不会在返回时复制它\n                  vec3 tangent,   //与使用&quot;in&quot;时行为相同\n                  inout vec3 coord) //复制进函数并在返回时复制\n 或者\n vec3 ComputeCoord(const vec3 normal, //不能写入normal\n                   vec3 tangent,  \n                   in vec3 coord)//函数将返回结果\n</code></pre><p>如果一个函数不返回任何值，必须声明为void类型。如果函数返回一个值，那么类型可以是除数组外的任何类型，不过可以返回结构，且结构可以包含数组。</p>\n<h2 id=\"内置函数重新定义\"><a href=\"#内置函数重新定义\" class=\"headerlink\" title=\"内置函数重新定义\"></a>内置函数重新定义</h2><pre><code>float sin(float x)\n{\n    return&lt;..some function of x&gt;    \n}\n\nvoid main()\n{\n    //调用上面的sin函数而不是内置的sin函数\n    float s = sin(x);    \n}\n</code></pre><p>操作（略）<br>索引（略）</p>\n<p>##混合</p>\n<pre><code>vec4 v4;\nv4.rgba;//是一个vec4，与使用v4是相同的。\nv4.rgb;//是一个vec3\nv4.b;//是浮点数\nv4.xy;//是一个vec2\nv4.xgba;//是非法的，各部分的名称x,gba不是来自于同一组\n</code></pre><p>各分量的名称可以打乱顺序，以便重新排列这些分量，或者重复各个分量。</p>\n<pre><code>vec4 pos = vec4(1.0,2.0,3.0,4.0);\nvec4 swiz = pos.wzyx; //swiz = (4.0,3.0,2.0,1.0)\nvec4 dup = pos.xxyy; //dup = (1.0,1.0,2.0,2.0)\n</code></pre><p>一次混合最多列出4个分量名称，否则会导致一个不存在的类型。对于R值（所读取的表达式，=后面的表达式）和L值（指定要写入何处的表达式，=号前面的表达式），混合的规则稍有不同。R值可以使用各部分的任意组合和重复。L值不能有任何重复。</p>\n<pre><code>vec4 pos = vec4(1.0,2.0,3.0,4.0);\npos.xw = vec2(5.0,6.0); //pos = (5.0,2.0,3.0,6.0)\npos.wx = vec2(7.0,8.0); //pos = (8.0,2.0,3.0,7.0)\npos.xx = vec2(3.0,4.0); //使用两次xx是非法的。\n</code></pre><p>对于R值来说，这种语法可以用在其最终类型为矢量的任何表达式上，如从一次纹理中获得一个有两部分的矢量：</p>\n<pre><code>vec2 v = texture1D(sampler,coord).xy;//内置函数texture1D返回的是一个vec4\n</code></pre><p>##按部分操作</p>\n<p>对一个矢量应用操作符时，其行为就像是独立应用于矢量的各个部分那样。</p>\n<p>例如：</p>\n<pre><code>vec3 v,u;\nfloat f;\nv = u+f;\n</code></pre><p>等价于</p>\n<p>v.x = u.x + f;<br>v.y = u.y + f;<br>v.z = u.z + f;</p>\n<pre><code>vec3 v,u,w;\nw = v + u;\n</code></pre><p>等价于<br>w.x = v.x + u.x;<br>w.y = v.y + u.y;<br>w.z = v.z + u.z;</p>\n<p>例外的情况是将一个矢量与一个矩阵相乘以及将一个矩阵与一个矩阵相乘，这时执行标准的线性代数乘法，而不是对各个部分相乘。</p>\n<pre><code>vec4 v,u;\nmat4 m;\nv * u ; //这是一个按部分乘法\nv * m ; //这是线性代数中的行矢量与矩阵相乘\nm * v;  //这是线性代数的矩阵与列矢量相乘\nm * m;  //这是线性代数中的矩阵与矩阵相乘\n</code></pre><p>其它所有的操作都是逐个部分地执行的。</p>\n<p>逻辑非！、逻辑与&amp;&amp;、逻辑或||、逻辑异或^^要求连接的两边都是布尔值，并生成一个布尔值。这些都不能在矩阵上操作。有一个内置函数not可以用来计算布尔矢量的按部分逻辑非。</p>\n<p>关系操作&lt;、&gt;、&lt;=、&gt;=只在浮点数和整数标量上操作，会生成一个布尔标量。可以使用内置函数如 LessThanEqual（GMS不能识别） 来计算两个矢量的按部分比较的布尔矢量结果。</p>\n<p>流控制结构if、for需要一个布尔标量，而布尔标量由等于==、不等于!=、关系操作和逻辑操作生成。</p>\n<p>如果调用内置的函数如equal来计算一个布尔矢量，那么可以使用内置函数any和all将这种矢量转换为一个布尔标量。</p>\n<p>赋值（=）要求左右边操作类型完成相同，可以对除了数组之外的任何类型赋值。</p>\n<p>预处理器（略）</p>\n<p>##顶点处理器</p>\n<p>此外<a href=\"/projects/gms/shader\">GMS shader参考</a>翻译了一部分。</p>\n","categories":[{"name":"教程","slug":"教程","count":7,"path":"api/categories/教程.json"}],"tags":[{"name":"GLSL","slug":"GLSL","count":1,"path":"api/tags/GLSL.json"}]}